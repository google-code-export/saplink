<?xml version="1.0" encoding="iso-8859-1"?>
<CLAS CLSNAME="ZSAPLINK_CLASS" VERSION="1" LANGU="E" DESCRIPT="SapLink Class Installer" UUID="4558408635A702C600000000A7E42BB6" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="620" CLSBCCAT="00" REFCLSNAME="ZSAPLINK">
 <publicSection>class ZSAPLINK_CLASS definition
  public
  inheriting from ZSAPLINK
  create public .

*&quot;* public components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .
  type-pools SEOP .
  type-pools SEOR .
  type-pools SEOS .
  type-pools SEOT .

  methods CHECKEXISTS
    redefinition .
  methods CREATEIXMLDOCFROMOBJECT
    redefinition .
  methods CREATEOBJECTFROMIXMLDOC
    redefinition .</publicSection>
 <protectedSection>*&quot;* protected components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!
protected section.

  methods DELETEOBJECT
    redefinition .
  methods GETOBJECTTYPE
    redefinition .</protectedSection>
 <privateSection>*&quot;* private components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!
private section.

  methods FINDIMPLEMENTINGCLASS
    importing
      !METHODNAME type STRING
      !STARTCLASS type STRING optional
    returning
      value(CLASSNAME) type STRING .</privateSection>
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <forwardDeclaration>ABAP</forwardDeclaration>
 <forwardDeclaration>SEOP</forwardDeclaration>
 <forwardDeclaration>SEOR</forwardDeclaration>
 <forwardDeclaration>SEOS</forwardDeclaration>
 <forwardDeclaration>SEOT</forwardDeclaration>
 <inheritance CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" STATE="1" AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204">
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CHECKEXISTS"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CREATEIXMLDOCFROMOBJECT"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CREATEOBJECTFROMIXMLDOC"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="DELETEOBJECT"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="GETOBJECTTYPE"/>
 </inheritance>
 <method CLSNAME="ZSAPLINK" CMPNAME="CHECKEXISTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CHECKEXISTS .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data classkey type SEOCLSKEY.
data not_active TYPE  SEOX_BOOLEAN.

  classKey-clsName = objname.

  call function &apos;SEO_CLASS_EXISTENCE_CHECK&apos;
    EXPORTING
      clskey        = classkey
    IMPORTING
      not_active    = not_active
    EXCEPTIONS
*      not_specified = 1
      not_existing  = 2.
*      is_interface  = 3
*      no_text       = 4
*      inconsistent  = 5
*      others        = 6.

  if sy-subrc &lt;&gt; 2.
    exists = &apos;X&apos;.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="CREATEIXMLDOCFROMOBJECT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CREATEIXMLDOCFROMOBJECT .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/


  DATA publicsection TYPE REF TO if_ixml_element.
  DATA protectedsection TYPE REF TO if_ixml_element.
  DATA privatesection TYPE REF TO if_ixml_element.
  DATA localimplementation TYPE REF TO if_ixml_element.
  DATA localtypes TYPE REF TO if_ixml_element.
  DATA localmacros TYPE REF TO if_ixml_element.
  DATA rootnode TYPE REF TO if_ixml_element.
  DATA reportlist TYPE STANDARD TABLE OF string.
  DATA includename TYPE program.
  DATA _classname TYPE seoclsname.
  DATA reportstring TYPE string.
  DATA rc TYPE sysubrc.
  DATA classdescr TYPE REF TO cl_abap_classdescr.
  DATA typedescr TYPE REF TO cl_abap_typedescr.
  DATA methoddescr TYPE abap_methdescr.
  DATA methodnode TYPE REF TO if_ixml_element.
  DATA parameternode TYPE REF TO if_ixml_element.
  DATA sourcenode TYPE REF TO if_ixml_element.
  DATA exceptionnode TYPE REF TO if_ixml_element.
  DATA exceptionlist TYPE seos_exceptions_r.
  DATA anexception TYPE vseoexcep.
  data inheritanceNode type ref to if_ixml_element.
  data redefNode type ref to if_ixml_element.

  DATA tempstring TYPE string.
  DATA methodkey TYPE seocpdkey.
  DATA clsmethkey TYPE seocmpkey.
  DATA methodproperties TYPE vseomethod.
  DATA classkey TYPE seoclskey.
  DATA classproperties TYPE vseoclass.
  DATA paramdescr TYPE abap_parmdescr.
  DATA paramkey TYPE seoscokey.
  DATA paramproperties TYPE vseoparam.
  DATA superclass TYPE REF TO cl_abap_typedescr.
  DATA superclassname TYPE string.
  DATA superclasskey TYPE seorelkey.

  DATA attribdescr TYPE abap_attrdescr.
  DATA attribkey TYPE seocmpkey.
  DATA attribproperties TYPE vseoattrib.
  DATA attribnode TYPE REF TO if_ixml_element.
  DATA inheritanceprops TYPE vseoextend.
  DATA redefines TYPE STANDARD TABLE OF seoredef
      WITH KEY clsname refclsname version mtdname.
  DATA inheritance TYPE SEOR_INHERITANCE_R.
  DATA redefinitions TYPE seor_redefinitions_r.
  data redefinition like line of redefinitions.
  DATA forwarddeclarationlist TYPE seot_typepusages_r.
  DATA forwarddeclaration TYPE REF TO if_ixml_element.
  DATA forwarddeclarationrow TYPE seot_typepusage_r.

  DATA otrnode TYPE REF TO if_ixml_element.
  DATA _otrguid TYPE sotr_conc.

  _classname = objname.
  classkey-clsname = objname.

*  setObjectType( ).

  DATA _objtype TYPE string.
*  _objType = objType.
  _objtype = getobjecttype( ).
  rootnode = xmldoc-&gt;create_element( _objtype ).
  CALL FUNCTION &apos;SEO_CLASS_GET&apos;
    EXPORTING
      clskey       = classkey
      version      = &apos;1&apos;
    IMPORTING
      class        = classproperties
    EXCEPTIONS
      not_existing = 1
      deleted      = 2
      is_interface = 3
      model_only   = 4.

  IF sy-subrc &lt;&gt; 0.
    CASE sy-subrc.
      WHEN 1.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING textid = zcx_saplink=&gt;not_found.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg = &apos;class deleted&apos;.
      WHEN 3.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg = &apos;interfaces not supported&apos;.
      WHEN 4.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg = &apos;class is modeled only&apos;.
    ENDCASE.
  ENDIF.

  setattributesfromstructure( node = rootnode structure =
  classproperties ).
  TRY.
      CALL METHOD cl_abap_classdescr=&gt;describe_by_name
        EXPORTING
          p_name         = objname
        RECEIVING
          p_descr_ref    = typedescr
        EXCEPTIONS
          type_not_found = 1.
      IF sy-subrc = 0.
        classdescr ?= typedescr.
      ELSE.

      ENDIF.
    CATCH cx_root.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING textid = zcx_saplink=&gt;system_error.
  ENDTRY.

  CALL METHOD classdescr-&gt;get_super_class_type
    RECEIVING
      p_descr_ref           = superclass
    EXCEPTIONS
      super_class_not_found = 1.

  IF sy-subrc = 0.
    superclassname = superclass-&gt;get_relative_name( ).
    IF NOT superclassname CS &apos;OBJECT&apos;.
      superclasskey-clsname = objname.
      superclasskey-refclsname = superclassname.
      CALL FUNCTION &apos;SEO_INHERITANC_GET&apos;
        EXPORTING
          inhkey        = superclasskey
        IMPORTING
          inheritance   = inheritanceprops
          redefinitions = redefines.
      setattributesfromstructure( node = rootnode structure =
      inheritanceprops ).
    ENDIF.
  ENDIF.

*/***TPJ - Added Logic for TYPES  -------------------*/
  DATA: types      TYPE seoo_types_r,
        wa_type    LIKE LINE OF types,
        types_node TYPE REF TO if_ixml_element.
  CALL FUNCTION &apos;SEO_TYPE_READ_ALL&apos;
    EXPORTING
      cifkey            = classkey
      version           = 1
    IMPORTING
      types             = types
    EXCEPTIONS
      clif_not_existing = 1
      OTHERS            = 2.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT types INTO wa_type.
    types_node = xmldoc-&gt;create_element( &apos;types&apos; ).
    setattributesfromstructure( node = types_node structure =
    wa_type ).
    rc = rootnode-&gt;append_child( types_node ).
  ENDLOOP.
*/***TPJ - End of Added Logic for TYPES  -------------------*/

*/***TPJ - Added Logic for Friends  -------------------*/
  DATA: clif_keys     TYPE STANDARD TABLE OF seoclskey,
        friends       TYPE STANDARD TABLE OF seofriends,
        wa_friend     LIKE LINE OF friends,
        friends_node  TYPE REF TO if_ixml_element.

  APPEND classkey TO clif_keys.
  CALL FUNCTION &apos;SEO_FRIENDS_SELECT&apos;
    EXPORTING
      WITH_EXTERNAL_REF = &apos;X&apos;
    TABLES
      clif_keys         = clif_keys
      friends_relations = friends.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT friends INTO wa_friend.
    friends_node = xmldoc-&gt;create_element( &apos;friends&apos; ).
    setattributesfromstructure( node = friends_node structure =
    wa_friend ).
    rc = rootnode-&gt;append_child( friends_node ).
  ENDLOOP.
*/***TPJ - End of Added Logic for Friends  -------------------*/

*/***ewH - Added Logic for Interfaces  -------------------*/
  DATA: it_implementings type seor_implementings_r,
        wa_implementings like line OF it_implementings,
        implementingNode TYPE REF TO if_ixml_element.

  CALL FUNCTION &apos;SEO_IMPLEMENTG_READ_ALL&apos;
    EXPORTING
      CLSKEY                   = classkey
    IMPORTING
      IMPLEMENTINGS            = it_implementings
    EXCEPTIONS
      CLASS_NOT_EXISTING       = 1
      OTHERS                   = 2.

  LOOP AT it_implementings INTO wa_implementings.
    implementingNode = xmldoc-&gt;create_element( &apos;implementing&apos; ).
    setattributesfromstructure( node = implementingNode structure =
    wa_implementings ).
    rc = rootnode-&gt;append_child( implementingNode ).
  ENDLOOP.
*/***ewH - End of Added Logic for Interfaces  -------------------*/
*/***rrq - Added Logic for EVENTS  -------------------*/
  DATA: events      TYPE SEOO_EVENTS_R,
        wa_event    LIKE LINE OF events,
        event_node  TYPE REF TO if_ixml_element,
        eventkey    type SEOCMPKEY,
        eventparams type seos_parameters_r,
        wa_params   type seos_parameter_r.
  CALL FUNCTION &apos;SEO_EVENT_READ_ALL&apos;
    EXPORTING
      cifkey            = classkey
      version           = 1
    IMPORTING
      events             = events
    EXCEPTIONS
      clif_not_existing = 1
      OTHERS            = 2.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT events INTO wa_event.
    eventkey-clsname = wa_event-clsname.
    eventkey-cmpname = wa_event-CMPNAME.
    event_node = xmldoc-&gt;create_element( &apos;events&apos; ).
    setattributesfromstructure( node = event_node structure =
    wa_event ).
    CALL FUNCTION &apos;SEO_EVENT_SIGNATURE_GET&apos;
      EXPORTING
        EVTKEY             = eventkey
      importing
       PARAMETERS         = eventparams.

*   parameters
    loop at eventParams into wa_params.

      parameternode = xmldoc-&gt;create_element( &apos;parameter&apos; ).
      setattributesfromstructure( node = parameternode
      structure = wa_params ).
      rc = event_node-&gt;append_child( parameternode ).
    ENDLOOP.
    rc = rootnode-&gt;append_child( event_node ).
  ENDLOOP.
*/***rrq - End of Added Logic for EVENTS  -------------------*/

*/--------------------------------------------------------------------\
*|                                                                    |
  includename = cl_oo_classname_service=&gt;get_pubsec_name( _classname ).
  READ REPORT includename INTO reportlist.
  publicsection = xmldoc-&gt;create_element( &apos;publicSection&apos; ).

  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = publicsection-&gt;if_ixml_node~set_value( reportstring ).
  CLEAR reportstring.
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_prosec_name( _classname ).
  READ REPORT includename INTO reportlist.
  protectedsection = xmldoc-&gt;create_element( &apos;protectedSection&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = protectedsection-&gt;if_ixml_node~set_value( reportstring ).
  CLEAR reportstring.
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_prisec_name( _classname ).
  READ REPORT includename INTO reportlist.
  privatesection = xmldoc-&gt;create_element( &apos;privateSection&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = privatesection-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccimp_name( _classname ).
  READ REPORT includename INTO reportlist.
  localimplementation = xmldoc-&gt;create_element( &apos;localImplementation&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localimplementation-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccdef_name( _classname ).
  READ REPORT includename INTO reportlist.
  localtypes = xmldoc-&gt;create_element( &apos;localTypes&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localtypes-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccmac_name( _classname ).
  READ REPORT includename INTO reportlist.
  localmacros = xmldoc-&gt;create_element( &apos;localMacros&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localmacros-&gt;if_ixml_node~set_value( reportstring ).
*|                                                                    |
*\--------------------------------------------------------------------/
  rc = rootnode-&gt;append_child( publicsection ).
  rc = rootnode-&gt;append_child( protectedsection ).
  rc = rootnode-&gt;append_child( privatesection ).
  rc = rootnode-&gt;append_child( localimplementation ).
  rc = rootnode-&gt;append_child( localtypes ).
  rc = rootnode-&gt;append_child( localmacros ).


  CALL FUNCTION &apos;SEO_TYPEPUSAGE_READ_ALL&apos;
    EXPORTING
      cifkey      = classkey
      version     = &apos;1&apos;
    IMPORTING
      typepusages = forwarddeclarationlist.
*comment rrq old way....forwardDeclarations the only attribute
*set was the &quot;TypeGroup&quot;
*the new way....the entire structure is passed as in node typeUsage
  LOOP AT forwarddeclarationlist INTO forwarddeclarationrow.
    forwarddeclaration = xmldoc-&gt;create_element( &apos;typeUsage&apos; ).
    setattributesfromstructure( node = forwarddeclaration structure =
    forwarddeclarationrow ).
    rc = rootnode-&gt;append_child( forwarddeclaration ).
  ENDLOOP.

*ewH: for version 0.1.3, we will continue to generate both nodes
* in order for upgradeability of saplink itself.  For version
* 2.0, forwardDeclaration node generations will be deprecated.
  LOOP AT forwarddeclarationlist INTO forwarddeclarationrow.
    forwarddeclaration = xmldoc-&gt;create_element( &apos;forwardDeclaration&apos; ).
    tempstring = forwarddeclarationrow-typegroup.
    rc = forwarddeclaration-&gt;if_ixml_node~set_value( tempstring ).
    rc = rootnode-&gt;append_child( forwarddeclaration ).
  ENDLOOP.

*  classDescriptor ?= cl_abap_typedescr=&gt;describe_by_name( className ).
  attribkey-clsname = objname.

  LOOP AT classdescr-&gt;attributes INTO attribdescr
  WHERE is_inherited = abap_false
  and is_interface = abap_false. &quot;rrq:issue 46
    attribnode = xmldoc-&gt;create_element( &apos;attribute&apos; ).
    attribkey-cmpname = attribdescr-name.
    CALL FUNCTION &apos;SEO_ATTRIBUTE_GET&apos;
      EXPORTING
        attkey    = attribkey
      IMPORTING
        attribute = attribproperties.

*   include OTR if necessary (for exception classes)
    IF attribproperties-type = &apos;SOTR_CONC&apos; AND attribproperties-attvalue
    IS NOT INITIAL.
      _otrguid = attribproperties-attvalue+1(32).
      otrnode = createnodefromotr( _otrguid ).
      if otrnode is bound.
        rc = attribnode-&gt;append_child( otrnode ).
      endif.
    ENDIF.

*   append attribute node to parent node
    setattributesfromstructure( node = attribnode structure =
    attribproperties ).
    rc = rootnode-&gt;append_child( attribnode ).
  ENDLOOP.

*// ewH: begin of logic for interface methods &amp; inheritance redesign--&gt;
* inheritances &amp; redefinitions: old source removed-recover w/subversion
  CALL FUNCTION &apos;SEO_INHERITANC_READ&apos;
    EXPORTING
      CLSKEY                   = classKey
    IMPORTING
      INHERITANCE              = inheritance
      REDEFINITIONS            = redefinitions
    EXCEPTIONS
      CLASS_NOT_EXISTING       = 1
      OTHERS                   = 2.

  if inheritance is not initial.
    inheritanceNode = xmldoc-&gt;create_element( &apos;inheritance&apos; ).
    setattributesfromstructure( node = inheritanceNode structure =
    inheritance ).

    loop at redefinitions into redefinition.
      redefNode = xmldoc-&gt;create_element( &apos;redefinition&apos; ).
      setattributesfromstructure( node = redefNode structure =
      redefinition ).
      rc = inheritanceNode-&gt;append_child( redefNode ).
    endloop.
    rc = rootnode-&gt;append_child( inheritanceNode ).
  endif.

* methods
  LOOP AT classdescr-&gt;methods INTO methoddescr where
  not ( is_inherited = &apos;X&apos; and is_redefined is initial ).
    methodkey-clsname = _classname.
    methodkey-cpdname = methoddescr-name.
*   interface methods
    if methoddescr-is_interface = &apos;X&apos;.
      CALL METHOD cl_oo_classname_service=&gt;get_method_include
        EXPORTING
          mtdkey              = methodkey
        RECEIVING
          result              = includename
        EXCEPTIONS
          method_not_existing = 1.
      IF sy-subrc = 0.
        methodnode = xmldoc-&gt;create_element( &apos;interfaceMethod&apos; ).
        setattributesfromstructure( node = methodnode structure =
        methodkey ).
        sourcenode = xmldoc-&gt;create_element( &apos;source&apos; ).
*        tempString = includeName.
*        rc = sourceNode-&gt;set_attribute(
*          name = &apos;includeName&apos; value = tempString ).
        READ REPORT includename INTO reportlist.
        reportstring = buildsourcestring( sourcetable = reportlist ).
        rc = sourcenode-&gt;if_ixml_node~set_value( reportstring ).
        rc = methodnode-&gt;append_child( sourcenode ).
        rc = rootnode-&gt;append_child( methodnode ).
      ENDIF.
*   other methods
    else.
      clsmethkey-clsname = _classname.
      clsmethkey-cmpname = methoddescr-name.
      CLEAR methodproperties.

      if methoddescr-is_redefined = &apos;X&apos;.
        methodnode = xmldoc-&gt;create_element( &apos;method&apos; ).
        move-corresponding clsMethKey to methodProperties.
*// ewh: begin of forward compatibility hack, can be removed for next
*//      major release--&gt;
        read table redefinitions into redefinition
          with key mtdname = methoddescr-name.
        if sy-subrc = 0.
          methodProperties-clsname = redefinition-refclsname.
        endif.
*//&lt;--ewH: end of forward compatibility hack
        setattributesfromstructure( node = methodnode structure =
        methodproperties ).
      else.
        CALL FUNCTION &apos;SEO_METHOD_GET&apos;
          EXPORTING
            mtdkey       = clsmethkey
          IMPORTING
            method       = methodproperties
          EXCEPTIONS
            not_existing = 1.
        IF sy-subrc = 0.
          methodnode = xmldoc-&gt;create_element( &apos;method&apos; ).
          setattributesfromstructure( node = methodnode structure =
          methodproperties ).

*         parameters
          LOOP AT methoddescr-parameters INTO paramdescr.
            CLEAR paramproperties.
            parameternode = xmldoc-&gt;create_element( &apos;parameter&apos; ).
            paramkey-cmpname = clsmethkey-cmpname.
            paramkey-sconame = paramdescr-name.
            paramkey-clsname = objname.
            CALL FUNCTION &apos;SEO_PARAMETER_GET&apos;
              EXPORTING
                parkey    = paramkey
                version   = &apos;1&apos;
              IMPORTING
                parameter = paramproperties.
            setattributesfromstructure( node = parameternode
            structure = paramproperties ).
            rc = methodnode-&gt;append_child( parameternode ).
          ENDLOOP.

*         exceptions
          CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
            EXPORTING
              mtdkey  = clsmethkey
              version = &apos;1&apos;
            IMPORTING
              exceps  = exceptionlist.
          LOOP AT exceptionlist INTO anexception.
            exceptionnode = xmldoc-&gt;create_element( &apos;exception&apos; ).
            setattributesfromstructure( node = exceptionnode
            structure = anexception ).
            rc = methodnode-&gt;append_child( exceptionnode ).
          ENDLOOP.
        endif. &quot;method found
      endif. &quot;is_redefined?
*     source
      CALL METHOD cl_oo_classname_service=&gt;get_method_include
        EXPORTING
          mtdkey              = methodkey
        RECEIVING
          result              = includename
        EXCEPTIONS
          method_not_existing = 1.
      IF sy-subrc = 0.
        READ REPORT includename INTO reportlist.
        reportstring = buildsourcestring( sourcetable = reportlist ).
        sourcenode = xmldoc-&gt;create_element( &apos;source&apos; ).
        rc = sourcenode-&gt;if_ixml_node~set_value( reportstring ).
        rc = methodnode-&gt;append_child( sourcenode ).
      endif.
      rc = rootnode-&gt;append_child( methodnode ).
    endif. &quot;is_interface?
  endloop.

* append root node to xmldoc
  rc = xmldoc-&gt;append_child( rootnode ).
  ixmldocument = xmldoc.
*// &lt;--ewH: end of logic for interface methods &amp; inheritance redesign
endmethod.</source>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="CREATEOBJECTFROMIXMLDOC" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CREATEOBJECTFROMIXMLDOC .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

  DATA rootnode TYPE REF TO if_ixml_element.
  DATA classkey TYPE seoclskey.
  DATA filter TYPE REF TO if_ixml_node_filter.
  DATA iterator TYPE REF TO if_ixml_node_iterator.
  DATA node TYPE REF TO if_ixml_element.
  DATA otrnode TYPE REF TO if_ixml_element.
  DATA filter2 TYPE REF TO if_ixml_node_filter.
  DATA iterator2 TYPE REF TO if_ixml_node_iterator.
  DATA superClass TYPE vseoextend-clsname.
  DATA superclasskey TYPE vseoextend.
  DATA methodsourcenode TYPE REF TO if_ixml_node.
  DATA sourcenode TYPE REF TO if_ixml_node.
  DATA source TYPE string.
  DATA sourcetable TYPE TABLE OF string.
  DATA methodkey TYPE seocpdkey.
  DATA node2 TYPE REF TO if_ixml_element.
  DATA _objtype TYPE string.
  data aobjname type e071-obj_name.
  data inheritanceNode type ref to if_ixml_element.
  data redefNode type ref to if_ixml_element.
  DATA includename TYPE program.

*data excClass type ref to ZCX_SAPLINK.

*// --&gt; begin of new data type rrq
data:
*exporting dataTypes
e_corrnr                 type TRKORR,
e_devclass               type DEVCLASS,
e_version                type SEOVERSION,
e_genflag                type GENFLAG,
e_authority_check        type SEOX_BOOLEAN,
e_overwrite              type SEOX_BOOLEAN,
*e_suppress_meth_gen      type SEOX_BOOLEAN,
*e_suppress_refac_gen     type SEOX_BOOLEAN,
e_method_sources         type SEO_METHOD_SOURCE_TABLE,
e_locals_def             type RSWSOURCET,
e_locals_imp             type RSWSOURCET,
e_locals_mac             type RSWSOURCET,
*e_suppress_ind_update    type SEOX_BOOLEAN,
*importing dataTypes
i_korrnr                 type trkorr,
*changing dataTypes
ch_class                 type VSEOCLASS,
ch_inheritance           type VSEOEXTEND,
ch_redefinitions         type SEOR_REDEFINITIONS_R,
ch_implementings         type SEOR_IMPLEMENTINGS_R,
ch_impl_details          type SEO_REDEFINITIONS,
ch_attributes            type SEOO_ATTRIBUTES_R,
ch_methods               type SEOO_METHODS_R,
ch_events                type SEOO_EVENTS_R,
ch_types                 type SEOO_TYPES_R,
ch_type_source           type SEOP_SOURCE,
ch_type_source_temp      type SEOP_SOURCE,
ch_parameters            type SEOS_PARAMETERS_R,
ch_exceps                type SEOS_EXCEPTIONS_R,
ch_aliases               type SEOO_ALIASES_R,
ch_typeusages            type SEOT_TYPEPUSAGES_R,
ch_clsdeferreds          type SEOT_CLSDEFERRDS_R,
ch_intdeferrds           type SEOT_INTDEFERRDS_R,
ch_friendships           type SEO_FRIENDS,
**table dataTypes
*tb_classDescription      type table of seoclasstx,
*tb_component_descr       type table of seocompotx,
*tb_subcomponent_descr    type table of seosubcotx,
* work areas for the tables
wa_attributes            type SEOO_ATTRIBUTE_R,
wa_types                 type SEOO_TYPE_R,
wa_friends               type seofriends,
wa_implementings         type SEOR_IMPLEMENTING_R,
wa_redefinitions         type SEOREDEF,
wa_methods               type SEOO_METHOD_R,
wa_parameters            type seos_parameter_r,
wa_exceps                type seos_exception_r,
wa_typeusages            type SEOT_TYPEPUSAGE_R, &quot;forward declarations
wa_method_Sources        type SEO_METHOD_SOURCE,
wa_events                type SEOO_EVENT_R.
data: lines type i.
*//&lt;-- end of new data types rrq

  CALL FUNCTION &apos;SEO_BUFFER_INIT&apos;.

  e_devclass = devclass.
  _objtype = getobjecttype( ).
  e_overwrite = overwrite.
  xmldoc = ixmldocument.
  rootnode = xmldoc-&gt;find_from_name( _objtype ).

  CALL METHOD getstructurefromattributes
    EXPORTING
      node      = rootnode
    CHANGING
      structure = ch_class.

  objname = classkey-clsname = ch_class-clsname.
  ch_class-version = &apos;0&apos;.
  superclass = rootnode-&gt;get_attribute( name = &apos;REFCLSNAME&apos; ).
  IF superclass IS NOT INITIAL.
* set something for inheritence
    superclasskey-clsname = classkey-clsname.
    superclasskey-refclsname = superclass.
    superclasskey-version = &apos;0&apos;.
    superclasskey-state = &apos;1&apos;.
    MOVE-CORRESPONDING superclasskey to ch_inheritance.
    ch_inheritance-author = &apos;BCUSER&apos;.
    ch_inheritance-createdOn = sy-datum.
  ENDIF.

*Add attributes to new class
  data otrConcept type SOTR_TEXT-CONCEPT.
  filter = xmldoc-&gt;create_filter_name( &apos;attribute&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
*   create OTR texts if necessary (for exception classes)
    clear otrConcept.
    otrnode = node-&gt;find_from_name( &apos;sotr&apos; ).
    IF otrnode IS NOT INITIAL.
*     ewH:33--&gt;create new concept with new guid
*      me-&gt;createotrfromnode( otrnode ).
      me-&gt;createotrfromnode(
        exporting node = otrnode
        importing concept = otrConcept ).
    ENDIF.
    clear wa_attributes.
*   create attribute
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_attributes.
    wa_attributes-version = &apos;0&apos;.
*   ewH:issue33--&gt;6.40 and above, must create new concept
    if otrConcept is not initial.
      concatenate `&apos;` otrConcept `&apos;` into wa_attributes-attvalue.
    endif.
    append wa_attributes to ch_attributes.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.

*/***TPJ - Added Logic for TYPES  -------------------*/
*  DATA: types           TYPE seoo_types_r,
*        type_properties LIKE LINE OF types.

  filter = xmldoc-&gt;create_filter_name( &apos;types&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_types.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_types.
    wa_types-version = &apos;0&apos;.
    append wa_types to ch_types.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*/***TPJ - End of Added Logic for TYPES  -------------------*/

*/***TPJ - Added Logic for Friends  -------------------*/
*  DATA: wa_friends type seofriends.

  filter = xmldoc-&gt;create_filter_name( &apos;friends&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_friends.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_friends.
    wa_friends-version = &apos;0&apos;.
    append wa_friends to ch_FRIENDSHIPS.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*/***TPJ - End of Added Logic for Friends  -------------------*/

*// ewH: Added Logic for Implementings(interfaces)--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;implementing&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_implementings.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_implementings.
    append wa_implementings to ch_implementings.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*//&lt;--ewH: End of Added Logic for Implementings(interfaces)

*// rrq: Added Logic for events--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;events&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_events.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_events.
    append wa_events to ch_events.
    filter2 = node-&gt;create_filter_name( &apos;parameter&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CLEAR wa_parameters.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_parameters.
      append wa_parameters to ch_parameters.
      node2 ?= iterator2-&gt;get_next( ).
    endwhile.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*//&lt;--rrq: End of Added Logic for events

*// ewH: start redesign method/inheritances--&gt;
* inheritance
  inheritanceNode = rootNode-&gt;find_from_name( &apos;inheritance&apos; ).
  if inheritanceNode is bound.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = inheritanceNode
      CHANGING
        structure = ch_inheritance.
*   redefs
    filter = inheritanceNode-&gt;create_filter_name( &apos;redefinition&apos; ).
    iterator = inheritanceNode-&gt;create_iterator_filtered( filter ).
    redefNode ?= iterator-&gt;get_next( ).
    WHILE redefNode IS NOT INITIAL.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = redefNode
        CHANGING
          structure = wa_redefinitions.
      append wa_redefinitions to ch_redefinitions.
      redefNode ?= iterator-&gt;get_next( ).
    ENDWHILE.
  endif.

*Add Methods to new class
  filter = xmldoc-&gt;create_filter_name( &apos;method&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_methods.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_methods.

*   only create metadata if method is not a redefinition
    read table ch_redefinitions into wa_redefinitions
    with key mtdname = wa_methods-cmpname.
    IF sy-subrc = 0.
      node ?= iterator-&gt;get_next( ).
      continue.
    endif.
*// ewh: begin of backward compatibility hack, can be removed for next
*//      major release--&gt;
    IF wa_methods-clsname &lt;&gt; ch_class-clsname.
      MOVE-CORRESPONDING wa_methods TO wa_redefinitions.
      wa_redefinitions-clsname = ch_class-clsname.
      wa_redefinitions-refclsname = wa_methods-clsname.
      wa_redefinitions-version = &apos;0&apos;.
      wa_redefinitions-mtdabstrct = &apos;&apos;.
      wa_redefinitions-mtdname = wa_methods-cmpname.
      APPEND wa_redefinitions TO ch_redefinitions.

      node ?= iterator-&gt;get_next( ).
      continue.
    endif.
*// &lt;--ewH: break in backward compatibility hack - 2Bcontinued below

    filter2 = node-&gt;create_filter_name( &apos;parameter&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CLEAR wa_parameters.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_parameters.
      append wa_parameters to ch_parameters.
      node2 ?= iterator2-&gt;get_next( ).
    ENDWHILE.
    filter2 = node-&gt;create_filter_name( &apos;exception&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_exceps.
      append wa_exceps to ch_exceps.
      node2 ?= iterator2-&gt;get_next( ).
    ENDWHILE.
    append wa_methods to ch_methods.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*// &lt;--ewH: end redesign method/inheritances
*// ewh: continuation of backward compatibility hack--&gt;
*  IF ( ch_redefinitions IS NOT INITIAL OR superclass-clsname
*  IS NOT INITIAL ) and ch_inheritance is initial.
*    CALL FUNCTION &apos;SEO_INHERITANC_CREATE_F_DATA&apos;
*      EXPORTING
*        save          = &apos; &apos;
*      CHANGING
*        inheritance   = superclasskey
*        redefinitions = ch_redefinitions.
*  ENDIF.
*// &lt;--ewH: end of backward compatibility hack


  DATA classtype TYPE seoclstype.
  DATA impkeys TYPE seor_implementing_keys.
  DATA iserror TYPE boolean.

*rrq comments Forward nodes are created in an old version of the
*create XML from object.  In that node, the only attribute set
*is the &quot;TypeGroup&quot;.  All other attributes are hard coded on the
*create Object from XML .  To fix this and make it transparent to
*users, &quot;forwaredDeclaration&quot; nodes will be supported, and a new
*node will be added.
*if it is an old version XML document, forwardDeclarations nodes
*if it is a new version XML document, typeUsages nodes

*ewH: for version 0.1.3, we will continue to generate both nodes
* in order for upgradeability of saplink itself.  For version
* 2.0, forwardDeclaration node generations will be deprecated.
  filter = xmldoc-&gt;create_filter_name( &apos;typeUsage&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
      CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_typeUsages.
    APPEND wa_typeusages TO ch_typeusages.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.

* only check forwardDeclaration if typeUsages does not exist
  if ch_typeusages is initial.
    filter = xmldoc-&gt;create_filter_name( &apos;forwardDeclaration&apos; ).
    iterator = xmldoc-&gt;create_iterator_filtered( filter ).
    node ?= iterator-&gt;get_next( ).

    WHILE node IS NOT INITIAL.
      source = node-&gt;get_value( ).
      wa_typeusages-typegroup = source.
      CLEAR wa_typeusages.
      wa_typeusages-clsname = classkey-clsname.
      wa_typeusages-version = &apos;0&apos;.
      wa_typeusages-tputype = &apos;0&apos;.
      wa_typeusages-explicit =  &apos;X&apos;.
      wa_typeusages-implicit = &apos;&apos;.
      wa_typeusages-typegroup = source.
      APPEND wa_typeusages TO ch_typeusages.
      node ?= iterator-&gt;get_next( ).
    ENDWHILE.
  endif.
* new way....only one of these nodes should exist
*  filter = xmldoc-&gt;create_filter_name( &apos;typeUsage&apos; ).
*  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
*  node ?= iterator-&gt;get_next( ).
*
*  WHILE node IS NOT INITIAL.
*      CALL METHOD getstructurefromattributes
*      EXPORTING
*        node      = node
*      CHANGING
*        structure = wa_typeUsages.
*    APPEND wa_typeusages TO ch_typeusages.
*    node ?= iterator-&gt;get_next( ).
*  ENDWHILE.
*Insert source code into the methods
  filter = xmldoc-&gt;create_filter_name( &apos;method&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_methods.
    methodkey-clsname = objname.
    methodkey-cpdname = wa_methods-cmpname.
    aobjname = methodkey.
    methodsourcenode = node-&gt;find_from_name( &apos;source&apos; ).
    IF methodsourcenode IS NOT INITIAL.
      clear wa_method_sources.
      source = methodsourcenode-&gt;get_value( ).
      sourcetable = buildtablefromstring( source ).
      loop at sourceTable into source.
        check source is not initial.
        translate source to upper case.
        shift source left deleting leading space.
        if source+0(6) = &apos;METHOD&apos;.
          delete sourceTable index sy-tabix.
          EXIT.
        endif.
      endloop.
      describe table sourceTable lines lines.
      while lines &gt; 0.
        read table sourceTable into source index lines.
        if source cp &apos;endmethod*&apos;.
          if sy-subrc  = 0 and source+0(1) &lt;&gt; &apos;*&apos;.
*          Got it and not a comment?
            delete sourceTable index lines.
            exit.
          endif.
        endif.
        subtract 1 from lines.
      endwhile.
      read table ch_redefinitions into wa_redefinitions
      with key mtdname = methodKey-cpdname.
      IF sy-subrc = 0.
        wa_method_sources-redefine = &apos;X&apos;.
      endif.
      wa_method_sources-cpdname = methodkey-cpdname.
      wa_method_sources-source = sourceTable.
      append wa_method_sources to e_method_sources.
    ENDIF.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*
**// ewH: create interface methods--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;interfaceMethod&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = methodKey.
    aobjname = methodkey.
    methodsourcenode = node-&gt;find_from_name( &apos;source&apos; ).
    IF methodsourcenode IS NOT INITIAL.
      clear wa_method_sources.
      source = methodsourcenode-&gt;get_value( ).
      sourcetable = buildtablefromstring( source ).
      loop at sourceTable into source.
        check source is not initial.
        translate source to upper case.
        shift source left deleting leading space.
        if source+0(6) = &apos;METHOD&apos;.
          delete sourceTable index sy-tabix.
          EXIT.
        endif.
      endloop.
      describe table sourceTable lines lines.
      while lines &gt; 0.
        read table sourceTable into source index lines.
        if source cp &apos;endmethod*&apos;.
          if sy-subrc  = 0 and source+0(1) &lt;&gt; &apos;*&apos;.
*          Got it and not a comment?
            delete sourceTable index lines.
            exit.
          endif.
        endif.
        subtract 1 from lines.
      endwhile.
      wa_method_sources-cpdname = methodkey-cpdname.
      wa_method_sources-redefine = wa_methods-redefin.
      wa_method_sources-source = sourceTable.

      append wa_method_sources to e_method_sources.
    ENDIF.

    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*// &lt;--ewH: end create interface methods

* local implementation
  DATA _classname TYPE seoclsname.
  _classname = objname.
  sourcenode = xmldoc-&gt;find_from_name( &apos;localImplementation&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    E_LOCALS_IMP = buildtablefromstring( source ).
  ENDIF.

* local types
  sourcenode = xmldoc-&gt;find_from_name( &apos;localTypes&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    E_LOCALS_DEF = buildtablefromstring( source ).
  ENDIF.

* local macros
  sourcenode = xmldoc-&gt;find_from_name( &apos;localMacros&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    E_LOCALS_MAC = buildtablefromstring( source ).
  ENDIF.

*ewH-not sure how this type_source param works. type sources can come
* from private or protected sections, but there is no way to pass
* these separately into the class create FM. After debugging into
* FM-&gt;clif_save_all-&gt;generate_classpool it treats the source table
* as one, so I am not sure how to get it to differentiate between
* private and protected sections. If only one section has types
* defined, the FM call works, otherwise all hell breaks loose. To
* solve the problem for now, we will just do an insert report for
* the sections after the class creation, since that&apos;s all the FM
* does in the end anyway. Wow, this is a really long comment, but
* I dont want to have to try to remember what the hell was going
* on here later...sorry.  :)
*insert code for publicSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;publicSection&apos; )
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source = buildtablefromstring( source ).
*  ENDIF.
**insert code for pivateSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;privateSection&apos; ).
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source_temp = buildtablefromstring( source ).
*    append lines of ch_type_source_temp to ch_type_source.
*  ENDIF.
**insert code for ProtectedSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;protectedSection&apos; ).
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source_temp = buildtablefromstring( source ).
*    append lines of ch_type_source_temp to ch_type_source.
*  ENDIF.

  name = objname.

CALL FUNCTION &apos;SEO_CLASS_CREATE_COMPLETE&apos;
 EXPORTING
   CORRNR                             = e_corrnr
   DEVCLASS                           = e_devclass
   VERSION                            = e_version
   GENFLAG                            = e_genflag
   AUTHORITY_CHECK                    = e_authority_check
   OVERWRITE                          = e_overwrite
*   SUPPRESS_METHOD_GENERATION         = e_suppress_meth_gen
*   SUPPRESS_REFACTORING_SUPPORT       = e_suppress_refac_gen
   METHOD_SOURCES                     = e_method_sources
   LOCALS_DEF                         = e_locals_def
   LOCALS_IMP                         = e_locals_imp
   LOCALS_MAC                         = e_locals_mac
*   SUPPRESS_INDEX_UPDATE              = e_suppress_ind_update
 IMPORTING
   KORRNR                             = i_korrnr
* TABLES
*   CLASS_DESCRIPTIONS                 = tb_classDescription
*   COMPONENT_DESCRIPTIONS             = tb_component_descr
*   SUBCOMPONENT_DESCRIPTIONS          = tb_subcomponent_descr
  CHANGING
    CLASS                              = ch_class
   INHERITANCE                        = ch_inheritance
   REDEFINITIONS                      = ch_redefinitions
   IMPLEMENTINGS                      = ch_implementings
   IMPL_DETAILS                       = ch_impl_details
   ATTRIBUTES                         = ch_attributes
   METHODS                            = ch_methods
   EVENTS                             = ch_events
   TYPES                              = ch_types
*   TYPE_SOURCE                        = ch_type_source &quot;???
   PARAMETERS                         = ch_parameters
   EXCEPS                             = ch_exceps
   ALIASES                            = ch_aliases
   TYPEPUSAGES                        = ch_typeusages
   CLSDEFERRDS                        = ch_clsdeferreds
   INTDEFERRDS                        = ch_intdeferrds
   FRIENDSHIPS                        = ch_friendships
 EXCEPTIONS
   EXISTING                           = 1
   IS_INTERFACE                       = 2
   DB_ERROR                           = 3
   COMPONENT_ERROR                    = 4
   NO_ACCESS                          = 5
   OTHER                              = 6
   OTHERS                             = 7.
  case sy-subrc.
    when &apos;0&apos;.
** i guess if we made it this far, we will assume success
** successful install
    when &apos;1&apos;.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING textid = zcx_saplink=&gt;existing.
    when others.
      raise exception type zcx_saplink
        exporting textid = zcx_saplink=&gt;system_error.
  endcase.

*ewH:insert pub, prot, and priv sections manually to keep any direct
* attribute/type definitions
* public
  sourcenode = xmldoc-&gt;find_from_name( &apos;publicSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_pubsec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_public STATE &apos;I&apos;.
  ENDIF.

* protected
  sourcenode = xmldoc-&gt;find_from_name( &apos;protectedSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_prosec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_protected STATE &apos;I&apos;.
  ENDIF.

* private
  sourcenode = xmldoc-&gt;find_from_name( &apos;privateSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_prisec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_private STATE &apos;I&apos;.
  ENDIF.

endmethod.</source>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="DELETEOBJECT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method DELETEOBJECT .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data clsKey type SEOCLSKEY.

  clsKey-clsname = objname.
  CALL FUNCTION &apos;SEO_CLASS_DELETE_W_DEPS&apos;
    EXPORTING
      clskey             = clsKey
    EXCEPTIONS
     NOT_EXISTING       = 1
     IS_INTERFACE       = 2
     NOT_DELETED        = 3
     DB_ERROR           = 4
     OTHERS             = 5
            .
  if sy-subrc &lt;&gt; 0.
    case sy-subrc.
      when 1.
        raise exception type zcx_saplink
          exporting textid = zcx_saplink=&gt;not_found.
      when 2.
        raise exception type zcx_saplink
          exporting
            textid = zcx_saplink=&gt;error_message
            msg = &apos;interfaces not supported&apos;.
      when 3.
        raise exception type zcx_saplink
          exporting
            textid = zcx_saplink=&gt;error_message
            msg = &apos;class not deleted&apos;.
      when others.
        raise exception type zcx_saplink
          exporting textid = zcx_saplink=&gt;system_error.
    endcase.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="620" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="METHODNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="STARTCLASS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="CLASSNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="USRRQ00" CREATEDON="20061130" CHANGEDBY="USRRQ00" CHANGEDON="20061204" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method FINDIMPLEMENTINGCLASS .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data methodKey type SEOCMPKEY.
data methodProperties type VSEOMETHOD.
data classDescr type ref to cl_abap_classdescr.
data superClass type ref to cl_abap_typeDescr.
data superClassName type string.

  if startClass is initial.
    methodKey-CLSNAME = objName.
  else.
    methodKey-clsName = startClass.
  endif.
  methodKey-CMPNAME = methodName.

  call function &apos;SEO_METHOD_GET&apos;
        exporting
          MTDKEY = methodKey
        importing
          method = methodProperties
        exceptions
          NOT_EXISTING = 1.
  if sy-subrc = 0.
    className = methodProperties-clsname.
  else.
    classDescr ?= cl_abap_classDescr=&gt;describe_by_name(
    methodKey-clsName ).
    call method classDescr-&gt;GET_SUPER_CLASS_TYPE
        receiving
         P_DESCR_REF = superClass
        exceptions
          SUPER_CLASS_NOT_FOUND = 1.
    superClassName = superClass-&gt;GET_RELATIVE_NAME( ).
    className = FINDIMPLEMENTINGCLASS( methodName = methodName
    startClass = superCLassName ).
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="GETOBJECTTYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method GETOBJECTTYPE .
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

  objecttype = &apos;CLAS&apos;.  &quot;Class

endmethod.</source>
 </method>
</CLAS>
